
import java.io.*;
import java.util.*;

public class HuffmanSubmit implements Huffman {
    //hashmap to store each bit-block and its huffman code 
    private static HashMap<String, String> codeTable = new HashMap<>();
    //simply the reverse of codetable, used for decoding 
    private static HashMap<String, String> decodeTable = new HashMap<>();
    //our minheap, used by buildhuffman
    private static PriorityQueue<HuffNode> minHeap;
    //this map stores the frequencies 
    private static HashMap<String, Integer> frequencey = new HashMap<>();
    //huffnNode used by buildHuffman
    private static HuffNode hufftree = null;
    //the array that stores the input as binary 
    private static String[] inputAsBinary;
    //counting how many bits are in the input 
    private static int count = 0;

    //the following two classes are used to build the huffman coding tree 
    private static class NodeComparator implements Comparator<HuffNode> {
        public int compare(HuffNode first, HuffNode second) {
            return first.weight - second.weight;
        }
    }

    private static class HuffNode {
        int weight;
        String data;
        HuffNode left;
        HuffNode right;
    }




    public void encode(String inputFile, String outputFile, String freqFile) {
        // TODO: Your code here
        //First we process the input, turn input an array of binary strings 
        processInput(inputFile);
        //then we build the huffman tree and write the frequncies 
        buildHuffman(frequencey, freqFile, true);
        //then we encode the inputFile useing the huffman codes 
        writeTheCode(outputFile, inputFile);
    }

    private static void processInput(String fileName) {
        int count = 0;
        BinaryIn in = new BinaryIn(fileName);
        //we proess text files differently 
        if (fileName.substring(fileName.length()-3, fileName.length()).equals("txt")){
            //we first check how many charcters we have in the text file 
            while (!in.isEmpty()){
                in.readChar();
                count++;
            }

            //then we set our binary string array to a new one with that count of chars 
            inputAsBinary = new String[count];
            //we reset our input 
            in = new BinaryIn(fileName);
            //then we write the characters as binary strings 
            for (int i = 0; (!in.isEmpty()); i++){
                //convert char to binary string 
                String binaryString = Integer.toBinaryString(in.readChar());
                //make sure that the binary string is accurate 
                while (binaryString.length()<7){
                    binaryString = '0'+ binaryString;
                }
                //calculate the frequencies of the binary strings 
                if (frequencey.containsKey(binaryString)){
                    int currentCount = frequencey.get(binaryString);
                    frequencey.put(binaryString, ++currentCount);
                } else {
                    frequencey.put(binaryString, 1);
                }
                //put the binary string in the binary string array 
                inputAsBinary[i] = binaryString;
            }
        } else {
            //processing non-text files
            //first check how many bits we have
            while (!in.isEmpty()){
                in.readBoolean();
                count++;
            }

            in = new BinaryIn(fileName);
            //create a bianry string array with 1/8 of that count because we want the chunks to be 8 bits
            inputAsBinary = new String[count/8];
            for (int i = 0; !in.isEmpty(); i++){
                String binaryString = "";
                for (int j = 0; (j<8 && !in.isEmpty()); j++){
                    boolean b = in.readBoolean();
                    if (b){
                        binaryString += '1';
                    } else {
                        binaryString += '0';
                    }
                }
                //calculate the frequency 
                if (frequencey.containsKey(binaryString)){
                    int currentCount = frequencey.get(binaryString);
                    frequencey.put(binaryString, ++currentCount);
                } else {
                    frequencey.put(binaryString, 1);
                }

                //insert it into the array 
                inputAsBinary[i] = binaryString;
            }

        }
    }

    //this method encodes the input based on the codes generated by huffman 
    private static void writeTheCode(String outputFile, String inputFile){
            BinaryOut out = new BinaryOut(outputFile);
            for (int i = 0; i<inputAsBinary.length; i++){
                //get the binary string 
                String code = codeTable.get(inputAsBinary[i]);
                //encode it as true or false 
                for (int j = 0; j<code.length(); j++){
                    if (code.charAt(j)=='1'){
                        out.write(true);
                    } else if (code.charAt(j)=='0'){
                        out.write(false);
                    }
                }
            }
            out.flush();
    }


    public void decode(String inputFile, String outputFile, String freqFile) {
        // TODO: Your code here

        // take the freq file, turn into frequency map
        frequencey = readFreq(freqFile);
        //create a huffman coding table based on the freq file 
        buildHuffman(frequencey, null, false);
        //count the number of bits in the input file 
        countFreq(freqFile);
        //then decode 
        simpleDecode(inputFile, outputFile);

    }

    //bsically take the freq file and turns it into a freq map 
    private static HashMap<String, Integer> readFreq(String freqFile){
        File file = new File(freqFile);
        FileReader  freqReader;
        HashMap<String, Integer> frequency = new HashMap<>();
        try {
            freqReader = new FileReader(file);
            BufferedReader reader = new BufferedReader(freqReader);
            String  line = "";
            while ((line=reader.readLine())!=null){
                //splitting each line by : 
                String[] splitLine = line.split(":");
                String code = splitLine[0];
                Integer freq = Integer.parseInt(splitLine[1]);
                //inserting into the frequency map 
                frequency.put(code, freq);
            }
        } catch (FileNotFoundException e){
            System.out.println(e);
        } catch (IOException e){
            System.out.println(e);
        }
        return frequency;
    }


    //this is a method to simply reverse the codetable
    private static void reverseCode(HashMap<String, String> codeTable){
        Iterator it = codeTable.entrySet().iterator();
        while (it.hasNext()){
            //  take each entry of codetable 
            Map.Entry pair = (Map.Entry) it.next();
            // put the key in place of the value and the value in place of the key 
            decodeTable.put(String.valueOf(pair.getValue()), String.valueOf(pair.getKey()));
            it.remove();
        }
    }

    private static void countFreq(String freqFile){
        //this method counts how many bits should be in the input file to limit binary input from reading more bits that neccessary
        File file = new File(freqFile);
        FileReader  freqReader;
        HashMap<String, Integer> frequency = new HashMap<>();
        //regenerate a frequency map. Since we're dealing with static objects, things can get weird. So we're creating a new frequency map 
        try {
            freqReader = new FileReader(file);
            BufferedReader reader = new BufferedReader(freqReader);
            String  line = "";
            while ((line=reader.readLine())!=null){
                String[] splitLine = line.split(":");
                String code = splitLine[0];
                Integer freq = Integer.parseInt(splitLine[1]);
                frequency.put(code, freq);
            }
        } catch (FileNotFoundException e){
            System.out.println(e);
        } catch (IOException e){
            System.out.println(e);
        }

        /*  
        the logic is simple,
        we can find how many bits we need to read by multiplying each frequncy by the length of the code
        */
        Iterator it = decodeTable.entrySet().iterator();
        while (it.hasNext()){
            Map.Entry pair = (Map.Entry) it.next();
            String code = String.valueOf(pair.getValue());
            count += (frequency.get(code) * String.valueOf(pair.getKey()).length());
        }
    }

    static void simpleDecode(String inputFile, String output){
        BinaryOut out = new BinaryOut(output);
        BinaryIn in = new BinaryIn(inputFile);
        String code = "";

            for (int i = 0; (!in.isEmpty()&& i<count); i++){
                boolean b = in.readBoolean();
                if (b){
                    code += '1';
                } else {
                    code += '0';
                }
                if (decodeTable.containsKey(code)){
                    if (output.substring(output.length()-3, output.length()).equals("txt")){
                        //decode, then write a char to the output file 
                        int parse = Integer.parseInt(decodeTable.get(code), 2);
                        char toadd = (char) parse;
                        out.write(toadd);
                    } else {
                        //get the proper binary string representation 
                        String codeToWrite = decodeTable.get(code);
                        for (int j = 0; j<codeToWrite.length(); j++){
                            //then write that binary to the output file 
                            if (codeToWrite.charAt(j)=='1'){
                                out.write(true);
                            } else if (codeToWrite.charAt(j)=='0'){
                                out.write(false);
                            } else {
                                throw new IllegalArgumentException();
                            }
                        }
                    }
                    code = "";
                }
            }
        out.flush();
    }



//biuldHuffman is used by both encode and decode 
    /*
    please note that buildhuffman was inspired by geeksforgeeks and the author 
    Kunwar Desh Deepak Singh 
    https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/
    Our huffmanTree was built based on Kunar's ideas
    */
    private static void buildHuffman(HashMap<String, Integer> tempFreq, String fileName, boolean encode) {
        minHeap = new PriorityQueue<>(tempFreq.size(), new NodeComparator());
        Iterator it = tempFreq.entrySet().iterator();

        if (encode){
            File file = new File(fileName);
            FileWriter w;
            try {
                w = new FileWriter(file);
                while (it.hasNext()) {
                    Map.Entry pair = (Map.Entry) it.next();
                    HuffNode toAdd = new HuffNode();
                    toAdd.data = pair.getKey().toString();
                    toAdd.weight = (int) pair.getValue();
                    toAdd.left = null;
                    toAdd.right = null;
                    minHeap.add(toAdd);
                    w.write(pair.getKey().toString()+":"+pair.getValue()+"\n");
                    it.remove();
                }
                w.close();
            } catch (IOException e){
                System.out.println(e);
            }
        } else {
            while (it.hasNext()) {
                Map.Entry pair = (Map.Entry) it.next();
                HuffNode toAdd = new HuffNode();
                toAdd.data = pair.getKey().toString();
                toAdd.weight = (int) pair.getValue();
                toAdd.left = null;
                toAdd.right = null;
                minHeap.add(toAdd);
                it.remove();
            }
        }

        while (minHeap.size() > 1) {
            //take out the first min value
            HuffNode min1 = minHeap.poll();
            //take out the second min value
            HuffNode min2 = minHeap.poll();
            //create a new node with the sum of the two
            HuffNode sum = new HuffNode();
            sum.weight = min1.weight + min2.weight;
            sum.data = null;
            //set min1 and min2 as children to the sum node
            sum.left = min1;
            sum.right = min2;
            //make this node the root
            hufftree = sum;
            //add to minHeap
            minHeap.add(sum);
        }
        generatecode(hufftree, "");
        if (!encode){
            reverseCode(codeTable);
        }
    }


    // used by buildhuffman 
    private static void generatecode(HuffNode root, String code) {
        //base case: if the left and right node are null, add the code
        if (root.left == null && root.right == null) {
            codeTable.put(root.data, code);
            return;
        }
        generatecode(root.left, code + "0");
        generatecode(root.right, code + "1");
    }



    





        public static void main (String[]args) {
            Huffman huffman = new HuffmanSubmit();
            Scanner scanner = new Scanner(System.in);
            System.out.println("to quit at any point, enter -1");
            System.out.println("Hello! to start encoding, enter 0. To start decoding, enter 1");
            int decide;
            String inputFile, outputFile, freqFile;
            while (true){
                decide = scanner.nextInt();
                while (decide!=0 && decide!=1){
                    if (decide == -1){
                        System.exit(0);
                    }
                    System.out.println("invalid input, try again");
                    decide = scanner.nextInt();
                }
                System.out.println("Enter input file name");
                inputFile = scanner.next();
                if (inputFile.equals("-1")){
                    System.exit(0);
                }
                System.out.println("Enter output file name");
                outputFile = scanner.next();
                if (outputFile.equals("-1")){
                    System.exit(0);
                }
                System.out.println("Enter freq file");
                freqFile = scanner.next();
                if (freqFile.equals("-1")){
                    System.exit(0);
                }
                if (decide == 0){
                    huffman.encode(inputFile, outputFile, freqFile);
                } else {
                    huffman.decode(inputFile, outputFile, freqFile);
                }
                System.out.println("It might take a few moments. Please be patient :)");
                System.out.println("Would you like to encode or decode another file? if so, enter 1. Otherwise, -1");
                decide = scanner.nextInt();
                while (decide != 1){
                    if (decide == -1){
                        System.exit(0);
                    }
                    System.out.println("Invalid input. To keep going enter 1, otherwise -1");
                }
                System.out.println("To encode, enter 0. to decode, enter 1");
                huffman = new HuffmanSubmit(); 
            }
        }
    }


